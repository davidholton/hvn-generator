import random
import json
import math
import os

module_dir = os.path.dirname(os.path.abspath(__file__))

# --------------------------------------------------------------------------- #

# The one time Lua beats out Python. Wish I had a rawset(_G, k, v)
with open(os.path.join(module_dir, "data/classes.json")) as f:
    classes = json.load(f)

with open(os.path.join(module_dir, "data/names.json")) as f:
    names = json.load(f)

with open(os.path.join(module_dir, "data/professions.json")) as f:
    professions = json.load(f)

with open(os.path.join(module_dir, "data/races.json")) as f:
    races = json.load(f)

with open(os.path.join(module_dir, "data/equipment.json")) as f:
    equipment = json.load(f)


def set_seed(seed: int) -> None:
    random.seed(seed)
    return


def roll(d: int, n: int, sort: bool = False, reverse: bool = False) -> list:
    """
    Return a list of random numbers generated by the dice-notation. Such as
    "AdX" where A is the number of rolls, and X is the number of faces on a
    dice. Additional parameters will sort the list in ascending or descending
    order.
    """

    rolls = [random.randint(1, n) for x in range(d)]

    if sort:
        rolls.sort(reverse=reverse)

    return rolls


skill_to_ability = {
    "athletics": "str",
    "acrobatics": "dex",
    "sleightHand": "dex",
    "stealth": "dex",
    "arcana": "int",
    "history": "int",
    "investigation": "int",
    "nature": "int",
    "religion": "int",
    "animalHandling": "wis",
    "insight": "wis",
    "medicine": "wis",
    "perception": "wis",
    "survival": "wis",
    "deception": "cha",
    "intimidation": "cha",
    "performance": "cha",
    "persuasion": "cha"
}

# --------------------------------------------------------------------------- #


def get_classes() -> list:
    """
    Return a list of possible classes
    """

    return list(classes.keys())


def get_professions() -> list:
    """
    Return a list of possible professions
    """

    low = professions.get("low")
    medium = professions.get("medium")
    high = professions.get("high")

    return low + medium + high


def get_professions_organized() -> dict:
    """
    Return a dict of possible professions organized by ranking
    """

    low = professions.get("low")
    medium = professions.get("medium")
    high = professions.get("high")

    return {"low": low, "medium": medium, "high": high}


def get_races() -> list:
    """
    Return a list of possible races
    """

    return list(races.keys())


def generate_power_score() -> int:
    """
    Creates the character's internal power score [1, 100]. Power score is used
    to determine how interesting a character information will be. Higher score
    means a character that has a higher potential
    """

    rolls = roll(3, 100, True)

    return rolls[0]


def generate_hit_dice(level, class_name) -> str:
    """
    Returns a string that follows dice-notation. Where rolls is the characters
    level and the dice is the predefined class hit dice.
    """

    dice = classes.get(class_name)["hdMax"]
    hit_dice = str(level) + "d" + str(dice)

    return hit_dice


def generate_hit_points(class_name, modifiers) -> int:
    """
    Calculates the hit points for a character. Based on constitution modifier
    plus highest value on the class assigned hit dice.
    """

    dice = classes.get(class_name)["hdMax"]
    hit_points = dice + modifiers["con"]

    return hit_points


def generate_level(power_score) -> int:
    """
    Returns a character level [1, 5] based off of a power score [1, 100]
    """

    return max(1, math.ceil(power_score / 20))


def generate_race() -> str:
    """
    From the JSON file make two lists. One for the population and the weights
    associated. Use random.choices to make a weighted choice.
    """

    population = []
    weights = []

    for race in races.items():
        population.append(race[0])
        weights.append(race[1]["weight"])

    # Subscripted to pull out from returned list
    race = random.choices(population, weights)[0]

    return race


def generate_gender() -> str:
    """
    Pick a random string from the genders list. Only "male" and "female".
    Uncertain if that will change. Good enough for now.
    """

    genders = ["male", "female"]
    gender = genders[random.randrange(len(genders))]

    return gender


def generate_first_name(race, gender) -> str:
    """
    Pick a random first name. There is a chance that the name will be from the
    race-neutral name set defined by `chance_of_neutral_name`.
    """

    # chance_of_neutral_name = 0.25

    # if random.random() <= chance_of_neutral_name:
    #     race = "neutral"

    # valid_names = data["names"].get(race)["first_names"].get(gender)
    # first_name = random.choice(valid_names)

    valid_names = names["genericFirst"].get(gender)
    first_name = random.choice(valid_names)

    return first_name


def generate_last_name(race) -> str:
    """
    Pick a random last name. There is a chance that the name will be from the
    race-neutral name set defined by `chance_of_neutral_name`.
    """

    # chance_of_neutral_name = 0.25

    # if random.random() <= chance_of_neutral_name:
    #     race = "neutral"

    # valid_names = data["names"].get(race)["last_names"]
    # last_name = random.choice(valid_names)

    valid_names = names["genericLast"]
    last_name = random.choice(valid_names)

    return last_name


def generate_full_name(race, gender) -> tuple:
    """
    Does what it do
    """

    first_name = generate_first_name(race, gender)
    last_name = generate_last_name(race)

    return (first_name, last_name)


def generate_class() -> str:
    """
    Same code as generate_races for now. See that for details.
    """

    population = []
    weights = []

    for class_name in classes.items():
        population.append(class_name[0])
        weights.append(class_name[1]["weight"])

    # Subscripted to pull out from returned list
    class_name = random.choices(population, weights)[0]

    return class_name


def generate_profession(power_score) -> str:
    """
    Takes power score translates that into a "profession bracket". High power
    score means a rarer profession. Check "professions.json" for the minimum
    threshold for each bracket.
    """

    bracket = "low"
    thresholds = professions["thresholds"]

    # Get the profession bracket
    for level in thresholds:
        if power_score >= thresholds.get(level):
            bracket = level
            break

    # From the bracket get the valid professions and pick a random one
    valid_professions = professions.get(bracket)
    profession = random.choice(valid_professions)

    return profession


def generate_ability_scores(race, class_name) -> tuple:
    """
    Generate the ability scores and their modifiers based off of race modifiers
    and proper class distributions
    """

    ability_scores = {
        "str": 0, "dex": 0, "con": 0,
        "int": 0, "wis": 0, "cha": 0,
    }

    ability_modifiers = {}

    A = 4
    X = 6
    # Grabs the three highest rolls from a AdX roll six times
    rolls = [sum(roll(A, X, True)[-3:]) for i in range(6)]
    # To ensure randomness for non distributed classes we do NOT sort rolls

    # Apply the class distribution
    distribution = classes.get(class_name)["distribution"]
    for ability in distribution:
        # Pop the largest roll
        largest = rolls.pop(rolls.index(max(rolls)))
        ability_scores[ability] += largest

    # Apply non-specified ability scores
    for ability in set(ability_scores) - set(distribution):
        score = rolls.pop()
        ability_scores[ability] += score

    # Adjust for race modifiers
    race_modifiers = races.get(race)["modifiers"]
    for ability in race_modifiers:
        ability_scores[ability] += race_modifiers[ability]

    # Create the final modifiers after race modifers are applied
    for ability, score in ability_scores.items():
        ability_modifiers[ability] = math.floor((score - 10) / 2)

    return (ability_scores, ability_modifiers)


def get_bonus(level) -> int:
    return math.ceil((level / 4) + 1)


def generate_saves(level, class_name, modifiers) -> tuple:
    """
    Generate the saving throw bonuses for each ability. Each bonus is the
    ability modifier. If the character class is proficient in the ability
    then add an additional bonus to that ability.
    """

    # Calculate the saving throw bonus per level
    bonus = get_bonus(level)
    prof_abilities = classes.get(class_name)["saveProf"]

    # Saving throw for each ability is the modifier + the bonus if they are
    # proficient in the ability
    saving_throws = {}
    for ability, modifier in modifiers.items():
        saving_throws[ability] = modifier
        if prof_abilities.get(ability):
            saving_throws[ability] += bonus

    return saving_throws


def generate_skills(level, class_name, modifiers) -> dict:
    """
    For each skill (in skill_to_ability) get the modifier based on its
    associated ability. If class is proficient in the skill add the level bonus
    """

    bonus = get_bonus(level)
    prof_skills = classes.get(class_name)["skillProf"]

    skills = {}
    for skill, ability in skill_to_ability.items():
        skills[skill] = modifiers[ability]
        if prof_skills.get(skill):
            skills[skill] += bonus

    return skills


def generate_armor(power_score, lvl, class_name, mods, one_hand=False) -> dict:
    """
    Generate the characters armor, shields, and armor class
    """

    prof_armor = classes.get(class_name)["equipProf"]["armor"]

    # Create a list of the proficient armors that the character can use
    # Weights are decided off of power score
    population = []
    weights = []

    if prof_armor.get("light"):
        population.append("light")
        weights.append(2 if power_score <= 20 else 1)

    if prof_armor.get("medium"):
        population.append("medium")
        weights.append(1 if power_score <= 20 else 2)

    if prof_armor.get("heavy"):
        population.append("heavy")
        weights.append(2 if power_score <= 50 else 3)

    # Pick the armor level
    armor_level = random.choices(population, weights)[0]
    # Get the possible armors from that level
    armors = list(equipment["armor"].get(armor_level))

    # Pick a random armor from that armor level
    # If we are picking from the heavy armor level and it happens to be a
    # full-plate armor make sure the character is at least level three
    while True:
        armor_name = random.choice(armors)

        if lvl >= 3 or armor_name != "plate":
            break

    armor = equipment["armor"].get(armor_level).get(armor_name)
    ac = armor["ac"]

    # Add dex modifier if applicable
    if armor["dex"]:
        ac += min(mods["dex"], armor["dexMax"])

    # Generate a shield if the character has a one handed weapon
    shield = False
    if prof_armor.get("shield") and one_hand:
        # Chance of having a shield increases by 25% per level
        # Max of 100% of course
        shield_chance = max(1, 0.25 * lvl)
        if random.random() <= shield_chance:
            ac += equipment["shield"]["acBonus"]
            shield = True

    return {"armor": armor_name, "shield": shield}, ac


# --------------------------------------------------------------------------- #


# if __name__ == "__main__":

#     power_score = generate_power_score()
#     print("Power Score:", power_score)

#     race = generate_race()
#     gender = generate_gender()
#     class_name = generate_class()
#     full_name = generate_full_name(race, gender)
#     profession = generate_profession(power_score)
#     level = generate_level(power_score)
#     ability_scores, ability_mods = generate_ability_scores(race, class_name)
#     saving_throws = generate_saves(level, class_name, ability_mods)
#     skill_throws = generate_skills(level, class_name, ability_mods)
#     hit_points = generate_hit_points(class_name, ability_mods)
#     hit_dice = generate_hit_dice(level, class_name)
#     armor, ac = generate_armor(power_score, level, class_name, ability_mods, True)

#     print("Name:", full_name[0], full_name[1])
#     print("Race:", race)
#     print("Gender:", gender)
#     print("Profession:", profession)
#     print("Level:", level)
#     print("Hit Points:", hit_points)
#     print("Hit Dice:", hit_dice)
#     print("Class:", class_name)
#     print("Stats:")
#     for ability, score in ability_scores.items():
#         sign = "+" if ability_mods[ability] >= 0 else ""
#         print(f"\t{ability}: {score:2d} ({sign}{ability_mods[ability]})")
#     print("Saving Throws:")
#     for ability, bonus in saving_throws.items():
#         sign = "+" if bonus >= 0 else ""
#         print(f"\t{ability}: {sign}{bonus}")
#     print("Skill Bonuses:")
#     for skill, bonus in skill_throws.items():
#         sign = "+" if bonus >= 0 else ""
#         print(f"\t{skill}: {sign}{bonus}")
