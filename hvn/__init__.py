import random
import json
import math
import os

module_dir = os.path.dirname(os.path.abspath(__file__))

# --------------------------------------------------------------------------- #

# The one time Lua beats out Python. Wish I had a rawset(_G, k, v)
with open(os.path.join(module_dir, "data/classes.json")) as f:
    classes = json.load(f)

with open(os.path.join(module_dir, "data/names.json")) as f:
    names = json.load(f)

with open(os.path.join(module_dir, "data/professions.json")) as f:
    professions = json.load(f)

with open(os.path.join(module_dir, "data/races.json")) as f:
    races = json.load(f)


def set_seed(seed: int) -> None:
    random.seed(seed)
    return


def roll(d: int, n: int, sort: bool = False, reverse: bool = False) -> list:
    """
    Return a list of random numbers generated by the dice-notation. Such as
    "AdX" where A is the number of rolls, and X is the number of faces on a
    dice. Additional parameters will sort the list in ascending or descending
    order.
    """

    rolls = [random.randint(1, n) for x in range(d)]

    if sort:
        rolls.sort(reverse=reverse)

    return rolls

# --------------------------------------------------------------------------- #


def generate_power_score() -> int:
    """
    Creates the character's internal power score [1, 100]. Power score is used
    to determine how interesting a character information will be. Higher score
    means a character that has a higher potential
    """
    rolls = roll(3, 100, True)

    return rolls[0]


def generate_hit_dice(level, class_name) -> str:
    """
    """
    dice = classes.get(class_name)["hdMax"]
    hit_dice = str(level) + "d" + str(dice)

    return hit_dice


def generate_level(power_score) -> int:
    """
    Returns a character level [1, 5] based off of a power score [1, 100]
    """
    return max(1, math.ceil(power_score / 20))


def generate_race() -> str:
    """
    From the JSON file make two lists. One for the population and the weights
    associated. Use random.choices to make a weighted choice.
    """

    population = []
    weights = []

    for race in races.items():
        population.append(race[0])
        weights.append(race[1]["weight"])

    # Subscripted to pull out from returned list
    race = random.choices(population, weights)[0]

    return race


def generate_gender() -> str:
    """
    Pick a random string from the genders list. Only "male" and "female".
    Uncertain if that will change. Good enough for now.
    """

    genders = ["male", "female"]
    gender = genders[random.randrange(len(genders))]

    return gender


def generate_first_name(race, gender) -> str:
    """
    Pick a random first name. There is a chance that the name will be from the
    race-neutral name set defined by `chance_of_neutral_name`.
    """

    # chance_of_neutral_name = 0.25

    # if random.random() <= chance_of_neutral_name:
    #     race = "neutral"

    # valid_names = data["names"].get(race)["first_names"].get(gender)
    # first_name = random.choice(valid_names)

    valid_names = names["genericFirst"].get(gender)
    first_name = random.choice(valid_names)

    return first_name


def generate_last_name(race) -> str:
    """
    Pick a random last name. There is a chance that the name will be from the
    race-neutral name set defined by `chance_of_neutral_name`.
    """

    # chance_of_neutral_name = 0.25

    # if random.random() <= chance_of_neutral_name:
    #     race = "neutral"

    # valid_names = data["names"].get(race)["last_names"]
    # last_name = random.choice(valid_names)

    valid_names = names["genericLast"]
    last_name = random.choice(valid_names)

    return last_name


def generate_full_name(race, gender) -> tuple:
    """
    Does what it do
    """

    first_name = generate_first_name(race, gender)
    last_name = generate_last_name(race)

    return (first_name, last_name)


def generate_class() -> str:
    """
    Same code as generate_races for now. See that for details.
    """
    population = []
    weights = []

    for class_name in classes.items():
        population.append(class_name[0])
        weights.append(class_name[1]["weight"])

    # Subscripted to pull out from returned list
    class_name = random.choices(population, weights)[0]

    return class_name


def generate_profession(power_score) -> str:
    """
    Takes power score translates that into a "profession bracket". High power
    score means a rarer profession. Check "professions.json" for the minimum
    threshold for each bracket.
    """
    bracket = "low"
    thresholds = professions["thresholds"]

    # Get the profession bracket
    for level in thresholds:
        if power_score >= thresholds.get(level):
            bracket = level
            break

    # From the bracket get the valid professions and pick a random one
    valid_professions = professions.get(bracket)
    profession = random.choice(valid_professions)

    return profession


def generate_ability_scores(race, class_name) -> tuple:
    """
    Generate the ability scores and their modifiers based off of race modifiers
    and proper class distributions
    """

    ability_scores = {
        "str": 0, "dex": 0, "con": 0,
        "int": 0, "wis": 0, "cha": 0,
    }

    ability_modifiers = {}

    A = 4
    X = 6
    # Grabs the three highest rolls from a AdX roll six times
    rolls = [sum(roll(A, X, True)[-3:]) for i in range(6)]
    # To ensure randomness for non distributed classes we do NOT sort rolls

    # Apply the class distribution
    distribution = classes.get(class_name)["distribution"]
    for ability in distribution:
        # Pop the largest roll
        largest = rolls.pop(rolls.index(max(rolls)))
        ability_scores[ability] += largest

    # Apply non-specified ability scores
    for ability in set(ability_scores) - set(distribution):
        score = rolls.pop()
        ability_scores[ability] += score

    # Adjust for race modifiers
    race_modifiers = races.get(race)["modifiers"]
    for ability in race_modifiers:
        ability_scores[ability] += race_modifiers[ability]

    # Create the final modifiers after race modifers are applied
    for ability, score in ability_scores.items():
        ability_modifiers[ability] = math.floor((score - 10) / 2)

    return (ability_scores, ability_modifiers)


def get_bonus(level) -> int:
    return math.ceil((level / 4) + 1)


def generate_saves(level, class_name, modifiers) -> tuple:
    """
    Generate the saving throw bonuses for each ability. Each bonus is the
    ability modifier. If the character class is proficient in the ability
    then add an additional bonus to that ability.
    """

    # Calculate the saving throw bonus per level
    bonus = get_bonus(level)
    prof_abilities = classes.get(class_name)["saveProf"]

    # Saving throw for each ability is the modifier + the bonus if they are
    # proficient in the ability
    saving_throws = {}
    for ability, modifier in modifiers.items():
        saving_throws[ability] = modifier
        if prof_abilities.get(ability):
            saving_throws[ability] += bonus

    return saving_throws

# --------------------------------------------------------------------------- #


# if __name__ == "__main__":

#     power_score = generate_power_score()
#     print("Power Score:", power_score)

#     race = generate_race()
#     gender = generate_gender()
#     class_name = generate_class()
#     full_name = generate_full_name(race, gender)
#     profession = generate_profession(power_score)
#     level = generate_level(power_score)
#     hit_dice = generate_hit_dice(level, class_name)
#     ability_scores, ability_mods = generate_ability_scores(race, class_name)
#     saving_throws = generate_saves(level, class_name, ability_mods)

#     print("Name:", full_name[0], full_name[1])
#     print("Race:", race)
#     print("Gender:", gender)
#     print("Profession:", profession)
#     print("Level:", level)
#     print("Hit Dice:", hit_dice)
#     print("Class:", class_name)
#     print("Stats:")
#     for ability, score in ability_scores.items():
#         sign = "+" if ability_mods[ability] >= 0 else ""
#         print(f"\t{ability}: {score:2d} ({sign}{ability_mods[ability]})")
#     print("Saving Throws:")
#     for ability, bonus in saving_throws.items():
#         sign = "+" if bonus >= 0 else ""
#         print(f"\t{ability}: {sign}{bonus}")
